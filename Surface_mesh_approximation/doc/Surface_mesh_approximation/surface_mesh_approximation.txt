namespace CGAL {
/*!
\mainpage User Manual
\anchor Chapter_Triangulated_Surface_Mesh_Approximation

\cgalAutoToc
\authors Pierre Alliez, Lingjie Zhu

\cgalFigureBegin{Approximation_masque_main, masque_vsa.png}
Running the variational shape approximation no the masque model (62k triangles). 
Left: the partition with 100 plane proxies on the input surface. 
Right: the extracted triangle mesh with less than 250 triangles.
\cgalFigureEnd

\section sma_introduction Introduction

For many applications ranging from geometry compression to reverse engineering,
finding the concise and faithful approximation of an excessively verbose 3D data 
(in particular, scanned meshes) is beneficial for subsequent processing and may 
reduce the computational cost dramatically.

This package implements the <em>Variational Shape Approximation</em> \cgalCite{cgal:cad-vsa-04} (VSA) 
method to approximate an input surface mesh by a simpler triangle surface mesh or triangle soup. Given a triangulated surface mesh 
(simply <em>mesh</em> in the following), the VSA uses the Lloyd's iteration \cgalCite{cgal:l-lsqp-82} 
to drive the parameterized primitive fitting error down. The overview of the algorithm can be found in \ref sma_approximation.

This package offers both the approximation and mesh extraction functionalities. 
They can be accessed through a free function or more advanced flexible class interfaces with customizable components. 
Apart from approximation, it can be viewed as a package for simplification or shape discovery or a complement to current mesh segmentation package.

\section sma_overview Overview

\subsection sma_approximation Variational Shape Approximation

The VSA method has two key concepts:

- <em>Geometric proxies</em> \f$ P \f$: as a best-fit geometric surrogate;

- <em>Shape error metrics</em> \f$ E \f$: to measure how well a proxy fits a piece of geometry \f$ \mathcal{R} \f$.

Given an error metric \f$ E \f$, a desired number of \f$ k \f$ proxies, 
and an input surface \f$ S \f$, we call <em>optimal shape proxies</em> a set \f$ P \f$ of proxies \f$ P_i \f$ 
associated to the regions \f$ R_i\f$ of a partition \f$ \mathcal{R} \f$ of \f$ S \f$ that minimizes the total fitting error \cgalCite{cgal:cad-vsa-04}:

\f[ E(\mathcal{R}, P) = \sum_{i = 1..k} E(\mathcal{R}_i, P_i). \f]

By casting the approximation problem into an optimal discrete clustering one, 
the algorithm utilize the simple and effective Lloyd algorithm \cgalCite{cgal:cad-vsa-04} to drive the total error down iteratively. 
More specifically, during every iteration, all facets are first partitioned into \f$ k \f$ regions by assigning each facet to its nearest proxy, which is called the <em>partition process</em>. 
Then, the algorithm updates each proxy \f$ P_i \f$ parameters with the corresponding region \f$ R_i \f$, which is called the <em>fitting process</em>. The iteration is repeated until a stopping criterion is met.

\subsection sma_metrics Metrics and Proxies

Intuitively each region \f$ \mathcal{R}_i \f$ of a partition \f$ \mathcal{R} \f$ can be summarily represented to first order as an "average" point \f$ X_i \f$ and an "average" normal \f$ N_i \f$. 
We denote such local representative pair \f$ P_i = (X_i, N_i) \f$, a <em>plane proxy</em> of the associated region. In the package, we provide such plane proxy as `CGAL::PlaneProxy`.

Defining an appropriate error metric is the key ingredient for the algorithm. 
The \f$ \mathcal{L}^2 \f$ metric is defined as:
\f[ \mathcal{L}^2(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert x - \Pi_i(x)\Vert^2 dx. \f] 
where \f$ \Pi_i(\cdot) \f$ denotes the orthogonal projection of the argument on the "proxy plane" going through \f$ X_i \f$ and normal to \f$ N_i \f$.

The \f$ \mathcal{L}^2 \f$ metric tries to match geometry through approximation of the geometric position. 
In the paper \cgalCite{cgal:cad-vsa-04}, the author proposed the \f$ \mathcal{L}^{2,1} \f$ metrics with the belief that normal field is fundamental to the visual interpretation of the shape. The \f$ \mathcal{L}^{2,1} \f$ is defined as:
\f[ \mathcal{L}^{2,1}(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert \mathbf{n}(x) - \mathbf{n}_i\Vert^2 dx. \f]

The \f$ \mathcal{L}^{2,1} \f$ is numerically superior to \f$ \mathcal{L}^2 \f$ in several ways:
- The anisotropy of the surface is better captured.
- Finding the best normal proxy is as simple as averaging the normals.

In \cgalFigureRef{relaxation}, we showed the Lloyd optimization iteration on a plane-sphere model with the \f$ \mathcal{L}^{2,1} \f$ metric.

\cgalFigureBegin{relaxation, relaxation.png}
Optimization on the plane-sphere model with the \f$ \mathcal{L}^{2,1} \f$ metric: (left) random initialization of 6 partitions; (center) after one iteration of optimization; (right) after 8 iterations, the regions settle. The red line represent the proxy normal parameter.
\cgalFigureEnd

In the package, we provide both two metrics as `CGAL::L2Metric` and `CGAL::L21Metric` respectively. 
Of course, we are not limited to those two metrics. The algorithm framework is extensible and we could define our own metrics and plug it in as we can see in \ref sma_example3.

\subsection sma_seeding Seeding

When we want to add a proxy to approximate the geometry, we have to specify a facet as the <em>seed</em> to initialize a proxy. The package provides 3 different seeding methods:
- <b>Random</b>. The proxy seeds are picked randomly from the geometry.
- <b>Incremental</b>. Each time a proxy is initialized from a facet seed of the worst region.
- <b>Hierarchical</b>. The requested number of proxies are dispatched within the current partition, where each region is added with the number of proxies proportional to their fitting error.

\cgalFigureBegin{seeding_method, seeding_method.png}
Comparison of different seeding methods on a sphere-cube union model, all with \f$ \mathcal{L}^{2,1} \f$ metrics and 20 proxies.
From left to right are random, incremental and hierarchical seeding respectively.
\cgalFigureEnd

From \cgalFigureRef{seeding_method} we can see the effect of different seeding strategies. Generally speaking, random initialization is random in position, very fast but can be entrapped in local minima areas (left), incremental one focuses on the most distorted region, interleaved with fitting process thus can be pretty slow. Hierarchical initialization gives fitting patches with more evenly distributed fitting errors and the time consumption is somewhere in between the former two.

To determine how many proxies do we need to approximate the geometry. The package provides two approaches:
- <b>Target number of proxies</b>. The seeding process will stop once the target number is reached.
- <b>Target error drop</b>. The seeding process will stop once the fitting error is drop below the target to the initial fitting error.

The former one is straight-forward and examples of the latter one can be found in \cgalFigureRef{meshing}. Some statistics and comparisons are available in \ref sma_perf.

\subsection sma_operations Refinement Operations

To get better approximation of the geometry, some refinement operations are available:
- <b>Merging</b>. Merging two adjacent regions.
- <b>Splitting</b>. Splitting bigger region into smaller ones to reduce the error. It is a reverse operation to merging.
- <b>Adding</b>. Adding a proxy to reduce the fitting error and approximate the geometry better. Just like seeding process, we can choose either incremental or hierarchical method.
- <b>Teleportation</b>. It is a combination of merging and adding proxies: merging the local minimum region to its adjacent area and adding a proxy seed to the worst region.

\cgalFigureBegin{operations, operations.png}
Refinement operations on the sphere-cube union model. Left is the partition of 20 randomly initialized proxies after 10 iterations. Right is the result of one merging and one teleportation operations.
\cgalFigureEnd

As we can see from \cgalFigureRef{operations}, teleportation could teleport entrapped local minima region (left) on the plane to the most needed regions on the sphere (right). In \ref sma_example2, the class interface is used to manipulate the approximation process with above operations.

\subsection sma_extraction Mesh Extraction

This package also implement the meshing algorithm described in \cgalCite{cgal:cad-vsa-04}. 
Basically, it attaches an anchor point to each intersection vertex and approximate the boundary of the geometry partition.
Then each polygon boundary is triangulated and assembled to produce the output mesh. 
Currently, there is no guarantee that the output mesh is 2-manifold and the package provide an alternate indexed triangles output.

\cgalFigureBegin{meshing, meshing.png}
Meshing on a bear model with decreasing target error drop. 
From left to right, the target error drop are 6\%, 4\% and 2\% to the initial error respectively, the output mesh densify. 
Notice the boundary subdivision in the black rectangle area.
\cgalFigureEnd

In \cgalFigureRef{meshing}, the bear model is approximated through \f$ \mathcal{L}^{2,1} \f$ metric and the number of proxies are determined by error drop. 
The anchor points (black) are attached to the corresponding vertex on the mesh (white). 
The red lines connecting the anchor points approximate the boundary of each region.

When approximate the boundary of the proxy region, the recursive chord-length subdividing technique described in \cgalCite{cgal:cad-vsa-04} is used to give better approximation as illustrated in \cgalFigureRef{meshing}. Basically, we add an extra anchor point when the furthest vertex of distance \f$ d \f$ on the boundary arc \f$ (\mathbf{a}, \mathbf{b}) \f$ is too far away. The subdivision criterion is defined as:
\f[ d\cdot sin(\mathbf{N}_i,\mathbf{N}_j)/\Vert(\mathbf{a}, \mathbf{b})\Vert, \f]
where \f$ \mathbf{N}_i,\mathbf{N}_j \f$ is the normal of the proxies separated by the boundary arc \f$ (\mathbf{a}, \mathbf{b}) \f$. 
If the angle between proxy \f$ P_i \f$ and \f$ P_j \f$ is rather small, even a coarse approximation of the boundary will do: it does not add geometric information on the shape. 
On the contrary, when there is a large angle in between the two proxies, a more accurate discretization is desirable. \cgalCite{cgal:cad-vsa-04}

\subsection sma_api API

This package can be used either with `Polyhedron_3`, `Surface_mesh`, or any class model of the concept `FaceGraph` described in \ref chapterBGL.

Free function with \ref namedparameters options.
- `CGAL::vsa_mesh_approximation()` : given a triangle mesh, approximate the geometry with default \f$ \mathcal{L}^{2,1} \f$ metric.

Class interface:
- `CGAL::VSA_approximation`: allowing more customization of the proxy, metric and approximation process.

The input of the algorithm is expected to be:
- Combinatorially 2-manifold
- Triangulated

\section sma_examples Examples

\subsection sma_example1 Free Function

The function parameters are provided through \ref namedparameters. 
To set the non-default parameter values, we just need to call the functions with the name of the required parameters connected by a dot in an arbitrary order like:

\code
vsa_mesh_approximation(input, output,
        CGAL::VSA::parameters::init_by_error(err_drop) // init the algorithm by target error drop
       .init_method(method) // set proxy seeding method in the initialization
       .iterations(num_iterations) // set number of fitting iterations after initialization
       .chord_subdivide(sub_thre) // set boundary subdivision threshold
       .facet_proxy_map(fpxmap) // output facet partition map
       .proxies(px_out_itr)); // output proxies
\endcode

The following example calls the free function `CGAL::vsa_mesh_approximation()` on the input triangle mesh with default `CGAL::L21Metric`.

\cgalExample{Surface_mesh_approximation/vsa_example.cpp}

As stated before, the package can also be used as a partition algorithm:
\code
// fpxmap: the output facet partition map
vsa_mesh_approximation(input, output,
        CGAL::VSA::parameters::init_by_number(num_proxies)
       .init_method(method)
       .iterations(num_iterations)
       .facet_proxy_map(fpxmap));
\endcode

\subsection sma_example2 Class Interface

The following example use the build-in `CGAL::L2Metric` to approximate the shape. 
With the class interface `CGAL::VSA_approximation`, we can achieve flexible and interactive manipulation of the algorithm.

\cgalExample{Surface_mesh_approximation/vsa_class_interface_example.cpp}

\subsection sma_example3 Self-defined Proxy and Metric

\cgalFigureBegin{vsa_metric_comparison, vsa_metric_comparison_200_30.png}
Comparison of different metrics on the bear model, all with 200 proxies and hierarchical seeding.
From left to right are \f$ \mathcal{L}^{2,1} \f$ metric, \f$ \mathcal{L}^2 \f$ metric and the compact metric.
\cgalFigureEnd

In the following example, it defines a simple point-wise proxy to achieves a compact patch approximation of the shape. The result is shown in \cgalFigureRef{vsa_metric_comparison}.

\cgalExample{Surface_mesh_approximation/vsa_metric_example.cpp}

\section sma_perf Performances

We provide some performance comparisons in this section with the free function API `CGAL::vsa_mesh_approximation`. 
The machine used is a PC running Windows10 X64 with an Intel Xeon E5-1620 clocked at 3.70 GHz with 32GB of RAM. 
The program has been optimized with the O2 option with Visual Studio 2015. By default the kernel used is `Exact_predicates_inexact_constructions_kernel` (`EPICK`).

Runtime in seconds with target number of proxies of different seeding method:

<center>
    Model    | \#Triangles | \#Proxies | Random | Incremental | Hierarchical
----------:  | ---------:  | -------:  | ----:  | ---------:  | -----------:
plane-sphere |    6,826    |     20    |     0  |     0.87    | 0.17
bear         |   20,188    |    200    |     0  |   36.749    | 1.194
masque       |   62,467    |    200    | 0.002  |  133.901    | 4.308
</center>

Runtime in seconds with target error drop of different seeding method. 
The benchmark is running on the bear model with 20,188 facets. 
Each column shows the time and the resulting number of proxies:

<center>
 Target Error Drop |   Random   | Incremental | Hierarchical
----------------:  | --------:  | ---------:  | -----------:
        0.06       |   1.03/64  |   9.053/53  | 1.017/64
        0.04       |  1.207/128 |  15.422/88  | 1.2/128
        0.02       |  1.415/256 |  35.171/192 | 1.428/256
</center>

Runtime of 3 phases of the algorithm in seconds: seeding, relaxation and meshing. 
The seeding method is hierarchical with target number of proxies.

<center>
    Model    | \#Triangles | \#Proxies | \#Iterations | Seeding | Relaxation | Meshing | Total
----------:  | ---------:  | -------:  | ----------:  | -----:  | --------:  | -----:  | ----:
plane-sphere |    6,826    |     20    |       20     |   0.17  |    0.228   | 0.044   | 0.442
bear         |   20,188    |    200    |       20     |  1.194  |    0.784   | 0.128   | 2.006
masque       |   62,467    |    200    |       20     |  4.308  |    2.974   | 0.349   | 7.631
</center>

<!-- With different metrics, we compare the running time and complexity of the output mesh.

<center>
    Model    | \#Triangles | \f$ \mathcal{L}^{2,1} \f$ | \f$ \mathcal{L}^2 \f$ | %Compact Metric
----------:  | ---------:  | -----------------------:  | -------------------:  | -------------:
plane-sphere |    6,826    |           tbd             |           tbd         | tbd
bear         |   20,188    |           tbd             |           tbd         | tbd
masque       |   62,467    |           tbd             |           tbd         | tbd
</center> -->

\section sma_history Design and Implementation History

This package is the result of the work of Lingjie Zhu during the 2017 season
of the Google Summer of Code. He has been mentored by Pierre Alliez.
The code is based on an initial research code written by Pierre Alliez in INRIA 2003,
for a paper published at \cgalCite{cgal:cad-vsa-04}.

*/

}
