namespace CGAL {
/*!
\mainpage User Manual
\anchor Chapter_Triangulated_Surface_Mesh_Approximation

\cgalAutoToc
\authors Pierre Alliez, Lingjie Zhu



\section sma_introduction Introduction

For many applications ranging from reverse engineering to computational engineering, finding the concise and faithful approximation of an excessively verbose 3D data (in particular, scanned meshes) is beneficial for subsequent processing and may reduce the computational cost dramatically.

This package implements the <em>Variational Shape Approximation</em> \cgalCite{cgal:cad-vsa-04} (VSA) method to approximate an input surface mesh by a simpler indexed face set or polyhedral surface mesh. 

Given an input surface triangle mesh, VSA leverages a discrete clustering algorithm to approximate it by a set of local simple shapes referred to as proxies. Each cluster is represented as a connected set of triangles of the input mesh, and the output mesh is constructed by generating a triangle mesh approximation of the clusters. 
By default the proxies are planar, and the algorithm design is generic for future extensions to non-planar proxies. 
The approximation error is one-side, defined between the clusters and their associated proxies. Two error metrics (\f$ \mathcal{L}^2 \f$, \f$ \mathcal{L}^{2,1} \f$) are provided via the classes `CGAL::VSA::L2_metric` and `CGAL::VSA::L21_metric`, and the algorithm design is generic to other user-defined metrics.


\cgalFigureBegin{Approximation_teaser, teaser.png}
Variational shape approximation on two models with the \f$ \mathcal{L}^{2,1} \f$ error metric. From left to right: partition of the input surface triangle mesh, anchor vertices and edges, and output triangle mesh. The partition is optimized via discrete clustering of the input triangles, so as to minimize the approximation error from the clusters to planar proxies (not shown). 
\cgalFigureEnd

This package offers both the approximation and mesh construction functionalities. They can be accessed through the free function `CGAL::VSA::mesh_approximation()`, which runs a fully automated version of the algorithm:

\cgalExample{Surface_mesh_approximation/vsa_simple_approximation_example.cpp}

A class interface is also provided for advanced users, with interactive capabilities during clustering and customization in terms of error and proxies. Apart from approximation, the package can be used for shape segmentation via another free function which provides access to the clustering partition.

\section sma_overview Overview

\subsection sma_clustering Clustering

Figure \cgalFigureRef{relaxation} depicts several Lloyd clustering iterations on the plane-sphere model with planar proxies and the \f$ \mathcal{L}^{2,1} \f$ metric.

\cgalFigureBegin{relaxation, relaxation.png}
Lloyd iterations on the plane-sphere model with planar proxies and the \f$ \mathcal{L}^{2,1} \f$ metric: (left) random initialization of 6 proxies; (center) after one iteration; (right) after 8 iterations, the regions settle. The red lines depict the proxy normals.
\cgalFigureEnd

On the right side of the figure is the fitting error curve at each iteration. After 8 iterations, the error barely changes. Based on this observation, we assume that the iteration converges if the error change of current iteration to the last one is less than a threshold (indicated by two green dash lines).

\subsection sma_init Initialization

<!-- As discussed above, the clustering iteration requires a set of initial proxies \f$ \{ P_1^0, \cdots, P_k^0 \} \f$.  -->

The clustering algorithm must be initialized by determining either the maximum number of proxies required to approximate the geometry or the minimum error drop rate between two iterations. More specifically, we can decide:
- <b>Maximum number of proxies</b>. The algorithm adds proxies until the specified target number is met.
- <b>Minimum error drop</b>. We start from the proxy fitted from the first facet of the surface with the fitting error \f$ \hat E \f$. The algorithm adds proxies until the approximation error drops below the specified percentage \f$ target\_drop * \hat E \f$, between two iterations.

\cgalFigureBegin{nb_proxies, nb_proxies.png}
Using different number of proxies to approximate the plane-sphere model. From left to right: 8, 14, 20 proxies. On the right most is the number_of_proxies to error curve.
\cgalFigureEnd

In figure \cgalFigureRef{nb_proxies}, if we specify the minimum error drop to 10% (yellow dash lines), we will end up with 12 proxies on the plane-sphere model. Different initialization examples are provided in \cgalFigureRef{meshing}.

\subsection sma_seeding Seeding

Seeding is used to decide how to insert a new proxy. 
Each proxy is always associated with a <em>seed</em> triangle facet in the input surface mesh. 
While the proxies may be viewed as centers (or best representative) in a geometric error sense, the seed of each proxy is used as the topological start point in the partition process. When we want to add more proxies to drive the approximation error down, we must specify facets of the input surface mesh as seeds to initialize the proxy parameters.

The package provides 3 different seeding methods:
- <b>Random</b>. The proxy seeds are picked randomly on the surface mesh.
- <b>Incremental</b>. Each new proxy is initialized from a facet of the worse region matching the largest approximation error. The facet itself is chosen as the one realizing the largest error in its region.
- <b>Hierarchical</b>. The requested number of proxies are dispatched within the current partition, where each region is refined with a number of proxies chosen in accordance to their fitting error. 

(TODO: precise formula used and justify)

\cgalFigureBegin{seeding_method, seeding_method.png}
Comparison of different seeding methods on the sphere-cube model. From left to right: initial partition (\f$ \mathcal{L}^{2,1} \f$ metrics and 20 proxies), add 5 proxy seeds (red facets) with random, incremental hierarchical methods respectively.
\cgalFigureEnd

Figure \cgalFigureRef{seeding_method} depicts the effect of different seeding methods to initialize the algorithm with 20 proxies. Random initialization randomly selects a set of input triangle facets as proxy seeds. It is very fast but the subsequent clustering process can be entrapped in local minima, especially on shapes with regions surrounded by sharp creases (left). Incremental initialization adds the proxies one by one at the most distorted region, interleaved with several inner iterations of clustering. It can thus be slow due to the interleaving with the clustering process. Hierarchical initialization adds proxies in a hierarchical refinement sequence, so as the generate clustering refions with more evenly distributed fitting errors. Time consumption is somewhere in-between the former two. Some statistics and comparisons are available in \ref sma_perf.

\subsection sma_operations Operations

For interactive use, the approach can yield better approximations of the geometry via adding/removing proxies and tunnelling out of local minima via additional operations:
- <b>Merging</b>. Merging two adjacent regions.
- <b>Splitting</b>. Splitting regions into smaller ones to reduce the error, by adding one or several proxies. 
% precise whether general N-section is possible or just bisection.
- <b>Adding</b>. Adding a proxy to further reduce the approximation error. As for the seeding process, addition can be performed incrementally or hierarchically. 
% precise if several proxy additions is possible.
- <b>Teleportation</b>. It is a combination of merging and adding proxies: merging the pair of adjacent region and adding a proxy seed to the worst region. More specifically, the pair of regions whose merging realizes the smallest error after merging and local re-fitting, is selected for merging. The teleport operation can temporarily either decrease or increase the total approximation error.
% explain whether teleport is performed even when the error increases. Say whether a force mode is available.  

\cgalFigureBegin{operations, operations.png}
Operations on the sphere-cube union model. Left: partition of 20 randomly initialized proxies after 10 iterations. Right: result after one merging and one teleportation operation.
\cgalFigureEnd

As depicted in Figure \cgalFigureRef{operations}, teleportation provides a means to relocate a local minimum region entrapped in the planar plart (left) to the most needed regions on the sphere (right). In \ref sma_example3, the class interface is used to control the approximation process through the aforementioned  operations.

\subsection sma_meshing Meshing

This package implements the meshing algorithm described in \cgalCite{cgal:cad-vsa-04} by generating a triangle mesh  approximation of the clustering partition. Intuitively, the triangulation is generated by computing a discrete analog of a constrained 2D Delaunay triangulation, where distances are measured on the graph of the input triangulation.

\cgalFigureBegin{triangulation, triangulation.png}
Discrete constrained triangulation. The triangulation process first constructs constrained edges between anchor vertices, by 'flooding' along the interface edges (black arrows). It then floods the inner vertices. Triangles are formed by connecting the sources of the flooding process. 
\cgalFigureEnd


More specifically, it first generates a set of so-called anchor vertices as follows: an anchor vertex is generated for each corner vertex of the clustering partition. A corner vertex of the input mesh exhibits adjacency to three regions for inner vertices, or two regions for boundary vertices. 
In order to approximate the complex boundaries of the clustering partition, additional anchor vertices are generated by recursive chord-length subdivision (Figure \cgalFigureRef{chord}). More specifically, an anchor vertex is added when the furthest vertex of distance \f$ d \f$ on the boundary arc \f$ (\mathbf{a}, \mathbf{b}) \f$ is too far away. The subdivision criterion is defined as: \f[ d\cdot sin(\mathbf{N}_i,\mathbf{N}_j)/\Vert(\mathbf{a}, \mathbf{b})\Vert, \f] where \f$ \mathbf{N}_i,\mathbf{N}_j \f$ is the normal of the proxies separated by the boundary arc \f$ (\mathbf{a}, \mathbf{b}) \f$. If the angle between proxy \f$ P_i \f$ and \f$ P_j \f$ is rather small, even a coarse approximation will do as it does not add geometric information on the shape. 
On the contrary, when there is a large angle in between the two proxies, a more accurate discretization is desirable. 

% explain how the user can control such an error: is it absolute error, or relative? 

\cgalFigureBegin{chord, chord.png}
Varying the chord error. From left to right: clustering partition, and meshing with decreasing chord error. The boundaries of the partition are approximated with increasing accuracy.
\cgalFigureEnd

Each clustering region delineated by anchor vertices boundary is then triangulated and the final anchor locations (not necessarily coinciding with the anchor vertices) are computed by averaging the projection of the anchor vertices on their respective proxies. 
% a future more generic implementation will offer possibility to write a customized functor.  


In \cgalFigureRef{meshing}, the bear model is approximated through \f$ \mathcal{L}^{2,1} \f$ metric and the final number of proxies is determined by monitoring the error drop. 
The anchor points (black) are attached to the corresponding vertex on the mesh (white). The red lines connecting the anchor points approximate the boundary of each region.

\cgalFigureBegin{meshing, meshing.png}
Meshing the bear model with decreasing target error drop. 
From left to right, the target error drop are 6\%, 4\% and 2\% to the initial error respectively, the output mesh densifies. 
Notice the boundary subdivision in the black rectangle area.
\cgalFigureEnd

As there is no guarantee that the output mesh is 2-manifold and oriented, the main input is an indexed triangle set. Additional output is possible in the form of a polyhedral surface mesh when the indexed triangle set represents a 2-manifold, oriented mesh. 




\subsection sma_api API

This package can be used either with `Polyhedron_3`, `Surface_mesh`, or any class model of the concept `FaceGraph` described in \ref chapterBGL.

Free function with \ref namedparameters options.
- `CGAL::VSA::mesh_approximation()` : given a triangle mesh, approximate the geometry with default \f$ \mathcal{L}^{2,1} \f$ metric.
- `CGAL::VSA::mesh_segmentation()` : given a triangle mesh, segment the geometry with default \f$ \mathcal{L}^{2,1} \f$ metric, no meshing process.

Class interface:
- `CGAL::VSA::Mesh_approximation`: allowing more customization of the proxy, metric and approximation process.

The input of the algorithm is expected to be:
- Triangulated
- Combinatorially 2-manifold 
- Oriented

\section sma_examples Examples

\subsection sma_example1 Free Function Approximation

The following example calls the free function `CGAL::VSA::mesh_approximation()` on the input triangle mesh with default `CGAL::VSA::L21_metric`.

\cgalExample{Surface_mesh_approximation/vsa_approximation_example.cpp}

Note that the function parameters are provided through \ref namedparameters. Setting the non-default parameter values requires calling the functions with the required parameters, connected by a dot and in an arbitrary order, as follows:

TODO: add output indexed face set to the code below, and verify that it compiles.

\code
// input: input triangle surface mesh
// output: indexed face set
typedef CGAL::Simple_cartesian<double> Kernel;
typedef CGAL::VSA::Plane_proxy<Kernel::VSA> Plane_proxy;
typedef std::map<face_descriptor, std::size_t> Facet_index_map;
typedef boost::associative_property_map<Facet_index_map> Facet_proxy_pmap;
Facet_index_map fidx_map;
BOOST_FOREACH(face_discriptor f, faces(input))
  fidx_map[f] = 0;
// facet proxy index property map
Facet_proxy_pmap fpxmap(fidx_map);
// plane proxies;
std::vector<Plane_proxy> proxies;
CGAL::VSA::mesh_approximation(input, 
        CGAL::VSA::parameters::min_error_drop(err_drop) // init the algorithm by target error drop
       .seeding_method(method) // set proxy seeding method
       .iterations(num_iterations) // set number of fitting iterations after seeding
       .mesh_chord_error(sub_thre) // set boundary approximation error threshold when meshing
       .facet_proxy_map(fpxmap) // get facet partition map
       .proxies(std::back_inserter(proxies))); // get proxies
\endcode

The facet proxy index map and the output proxies provide a means to access the partition and the proxy parameters as illustrated by \cgalFigureRef{relaxation}. 

\subsection sma_example2 Free Function Segmentation

The package can be used for segmenting the input mesh via the free function `CGAL::VSA::mesh_segmentation()`, with the default `CGAL::VSA::L21_metric` approximation:

\cgalExample{Surface_mesh_approximation/vsa_segmentation_example.cpp}

\subsection sma_example3 Class Interface

The class interface `CGAL::VSA::Mesh_approximation` offers a means to achieve flexible and interactive control of the algorithm. The following example uses the L2 metric class  `CGAL::VSA::L2_metric` to approximate the shape.

\cgalExample{Surface_mesh_approximation/vsa_class_interface_example.cpp}

\subsection sma_example4 Customized Proxy and Error Metric

\cgalFigureBegin{vsa_metric_comparison, vsa_metric_comparison_200_30.png}
Comparison of different metrics on the bear model, with 200 proxies and hierarchical seeding. From left to right: \f$ \mathcal{L}^{2,1} \f$ metric, \f$ \mathcal{L}^2 \f$ metric and compact metric.
\cgalFigureEnd

The following example defines a point-wise proxy to yield an isotropic approximation. The output mesh is depicted in Figure \cgalFigureRef{vsa_metric_comparison}.

\cgalExample{Surface_mesh_approximation/vsa_isotropic_metric_example.cpp}

\section sma_perf Performances

We provide some performance comparisons with the free function API `CGAL::VSA::mesh_approximation`. 
Timings are recorded on a PC running Windows10 X64 with an Intel Xeon E5-1620 clocked at 3.70 GHz with 32GB of RAM. 
The program has been optimized with the O2 option with Visual Studio 2015. By default the kernel used is `Exact_predicates_inexact_constructions_kernel` (`EPICK`).

Runtime in seconds with target number of proxies of different seeding method:

<center>
    Model    | \#Triangles | \#Proxies | Random | Incremental | Hierarchical
----------:  | ---------:  | -------:  | ----:  | ---------:  | -----------:
plane-sphere |    6,826    |     20    |     0  |     0.87    | 0.17
bear         |   20,188    |    200    |     0  |   36.749    | 1.194
masque       |   62,467    |    200    | 0.002  |  133.901    | 4.308
</center>

Runtime in seconds with target error drop of different seeding method. The benchmark is running on the bear model with 20,188 facets. Each column records the time and the resulting number of proxies:

<center>
 Target Error Drop |   Random   | Incremental | Hierarchical
----------------:  | --------:  | ---------:  | -----------:
        0.06       |   1.03/64  |   9.053/53  | 1.017/64
        0.04       |  1.207/128 |  15.422/88  | 1.2/128
        0.02       |  1.415/256 |  35.171/192 | 1.428/256
</center>

Runtime of 3 phases of the algorithm in seconds: seeding, relaxation and meshing. The seeding method is hierarchical with target number of proxies.

<center>
    Model    | \#Triangles | \#Proxies | \#Iterations | Seeding | Relaxation | Meshing | Total
----------:  | ---------:  | -------:  | ----------:  | -----:  | --------:  | -----:  | ----:
plane-sphere |    6,826    |     20    |       20     |   0.17  |    0.228   | 0.044   | 0.442
bear         |   20,188    |    200    |       20     |  1.194  |    0.784   | 0.128   | 2.006
masque       |   62,467    |    200    |       20     |  4.308  |    2.974   | 0.349   | 7.631
</center>

<!-- With different metrics, we record the running time and complexity of the output mesh.

<center>
    Model    | \#Triangles | \f$ \mathcal{L}^{2,1} \f$ | \f$ \mathcal{L}^2 \f$ | %Compact Metric
----------:  | ---------:  | -----------------------:  | -------------------:  | -------------:
plane-sphere |    6,826    |           tbd             |           tbd         | tbd
bear         |   20,188    |           tbd             |           tbd         | tbd
masque       |   62,467    |           tbd             |           tbd         | tbd
</center> -->

\section sma_background Background

The VSA method has two key geometric concepts:

- <b>Proxies</b> \f$ P \f$. The parameterized best-fit surrogates of a piece of surface geometry.

- <b>Error metrics</b> \f$ E \f$. To measure how well a proxy approximates the corresponding geometry.

Given an error metric \f$ E \f$, a desired number of \f$ k \f$ proxies, 
and an input surface \f$ S \f$, we denote by <em>optimal shape proxies</em> a set \f$ P \f$ of proxies \f$ P_i \f$ associated to the regions \f$ R_i\f$ of a partition \f$ \mathcal{R} \f$ of \f$ S \f$ that minimizes the total fitting error \cgalCite{cgal:cad-vsa-04}:

\f[ E(\mathcal{R}, P) = \sum_{i = 1..k} E(\mathcal{R}_i, P_i). \f]

By casting the approximation problem into an optimal discrete clustering one, the algorithm leverages the effective Lloyd algorithm \cgalCite{cgal:cad-vsa-04} to drive the total error down iteratively. 
More specifically, during each iteration two different steps are conducted, for the \f$ m \f$th iteration:
- <b>Partition process</b>. Firstly, all triangle facets are partitioned into \f$ k \f$ connected regions \f$ \{ R^{m}_1, \cdots, R^{m}_k \} \f$ by assigning each facet to its nearest proxy \f$ P^{m-1}_i \f$.
- <b>Fitting process</b>. Then, the algorithm fits a proxy and update the parameters \f$ P^{m}_i \f$ from the corresponding region \f$ R^{m}_i \f$.

For a sequence of iteration with the fitting error \f$ \{ E^1, \cdots, E^m \} \f$, the iteration is repeated until one of the stopping criteria is met:
- The maximum number of iteration is reached: \f$ m >= max\_iterations \f$.
- No significant error change between two iterations: \f$ (E^{m-1} - E^{m}) / E^{m-1} < converge\_threshold \f$.

Intuitively, each region \f$ \mathcal{R}_i \f$ of a partition \f$ \mathcal{R} \f$ can be summarily represented to first order as an "average" point \f$ X_i \f$ and an "average" normal \f$ N_i \f$. 
We denote such local representative pair \f$ P_i = (X_i, N_i) \f$, a <em>planar proxy</em> of the associated region. In the package, we provide such a planar proxy as `CGAL::VSA::Plane_proxy`.

Defining an appropriate error metric is the key ingredient for the algorithm. 
The \f$ \mathcal{L}^2 \f$ metric is defined as:
\f[ \mathcal{L}^2(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert x - \Pi_i(x)\Vert^2 dx. \f] where \f$ \Pi_i(\cdot) \f$ denotes the orthogonal projection of the argument onto the proxy plane passing through \f$ X_i \f$ and normal to \f$ N_i \f$. The \f$ \mathcal{L}^2 \f$ metric tries to match the input shape through approximation of the geometric position. 

In the paper \cgalCite{cgal:cad-vsa-04}, the author proposed the \f$ \mathcal{L}^{2,1} \f$ metrics, arguing that the normals are fundamental to the visual interpretation of the shape. The \f$ \mathcal{L}^{2,1} \f$ is defined as: \f[ \mathcal{L}^{2,1}(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert \mathbf{n}(x) - \mathbf{n}_i\Vert^2 dx. \f]

The \f$ \mathcal{L}^{2,1} \f$ is numerically superior to \f$ \mathcal{L}^2 \f$ in several ways:
- The anisotropy of the surface is better captured.
- Finding the best normal proxy is as simple as averaging the normals.


\section sma_history Design and Implementation History

This package is the result of the work of Lingjie Zhu during the 2017 season of the Google Summer of Code, mentored by Pierre Alliez. The code is based on an initial research code written by Pierre Alliez at Inria in 2003, for a paper published at the ACM SIGGRAPH conference in 2004 \cgalCite{cgal:cad-vsa-04}.

*/

}
