namespace CGAL {
/*!
\mainpage User Manual
\anchor Chapter_Triangulated_Surface_Mesh_Approximation

\cgalAutoToc
\authors Pierre Alliez, Lingjie Zhu

\cgalFigureBegin{Approximation_masque_main, masque_vsa.png}
Running the variational shape approximation on the mask model (62k triangles) with \f$ \mathcal{L}^{2,1} \f$ metric. 
Left: partition with 100 planar proxies on the input surface. 
Right: extracted triangle mesh with less than 250 triangles.
\cgalFigureEnd

\section sma_introduction Introduction

For many applications ranging from geometry compression to reverse engineering, finding the concise and faithful approximation of an excessively verbose 3D data (in particular, scanned meshes) is beneficial for subsequent processing and may reduce the computational cost dramatically.

This package implements the <em>Variational Shape Approximation</em> \cgalCite{cgal:cad-vsa-04} (VSA) method to approximate an input surface mesh by a simpler triangle surface mesh or triangle soup. Given a triangulated surface mesh, referred to as <em>mesh</em> in the following, VSA leverages the Lloyd's iteration \cgalCite{cgal:l-lsqp-82} 
to drive the approximation error down between the input surface triangle mesh and a set of geometric proxies. By default the proxies are planar, but the algorithm design is generic for future extensions to non-planar proxies. Two error metrics (\f$ \mathcal{L}^2 \f$, \f$ \mathcal{L}^{2,1} \f$) are provided, but the algorithm is generic to other user-defined metrics.

An overview of the algorithm is provided in \ref sma_approximation.

This package offers both the approximation and mesh extraction functionalities. They can be accessed through a free function or more advanced flexible class interfaces with customizable steps and parameters. 
Apart from approximation, the package can be used for shape analysis or a complement to the current mesh segmentation package.

\section sma_overview Overview

\subsection sma_approximation Variational Shape Approximation

The VSA method has two key concepts:

- <b>Geometric proxies</b> \f$ P \f$. The parameterized best-fit geometric surrogates of a piece of surface geometry.

- <b>Shape error metrics</b> \f$ E \f$. To measure how well a proxy approximates the corresponding geometry.

Given an error metric \f$ E \f$, a desired number of \f$ k \f$ proxies, 
and an input surface \f$ S \f$, we denote by <em>optimal shape proxies</em> a set \f$ P \f$ of proxies \f$ P_i \f$ associated to the regions \f$ R_i\f$ of a partition \f$ \mathcal{R} \f$ of \f$ S \f$ that minimizes the total fitting error \cgalCite{cgal:cad-vsa-04}:

\f[ E(\mathcal{R}, P) = \sum_{i = 1..k} E(\mathcal{R}_i, P_i). \f]

By casting the approximation problem into an optimal discrete clustering one, the algorithm leverages the effective Lloyd algorithm \cgalCite{cgal:cad-vsa-04} to drive the total error down iteratively. 
More specifically, during each iteration two different steps are conducted, for the \f$ m \f$th iteration:
- <b>Partition process</b>. Firstly, all triangle facets are partitioned into \f$ k \f$ connected regions \f$ \{ R^{m}_1, \cdots, R^{m}_k \} \f$ by assigning each facet to its nearest proxy \f$ P^{m-1}_i \f$.
- <b>Fitting process</b>. Then, the algorithm fits a proxy and update the parameters \f$ P^{m}_i \f$ from the corresponding region \f$ R^{m}_i \f$.

For a sequence of iteration with the fitting error \f$ \{ E^1, \cdots, E^m \} \f$, the iteration is repeated until one of the stopping criteria is met:
- The maximum number of iteration is reached: \f$ m >= max\_iterations \f$.
- No significant error change between two iterations: \f$ (E^{m-1} - E^{m}) / E^{m-1} < converge\_threshold \f$.

\subsection sma_metrics Metrics and Proxies

Intuitively, each region \f$ \mathcal{R}_i \f$ of a partition \f$ \mathcal{R} \f$ can be summarily represented to first order as an "average" point \f$ X_i \f$ and an "average" normal \f$ N_i \f$. 
We denote such local representative pair \f$ P_i = (X_i, N_i) \f$, a <em>planar proxy</em> of the associated region. In the package, we provide such plane proxy as `CGAL::PlaneProxy`.

Defining an appropriate error metric is the key ingredient for the algorithm. 
The \f$ \mathcal{L}^2 \f$ metric is defined as:
\f[ \mathcal{L}^2(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert x - \Pi_i(x)\Vert^2 dx. \f] where \f$ \Pi_i(\cdot) \f$ denotes the orthogonal projection of the argument onto the "proxy plane" going through \f$ X_i \f$ and normal to \f$ N_i \f$.

The \f$ \mathcal{L}^2 \f$ metric tries to match geometry through approximation of the geometric position. 
In the paper \cgalCite{cgal:cad-vsa-04}, the author proposed the \f$ \mathcal{L}^{2,1} \f$ metrics with the belief that normal field is fundamental to the visual interpretation of the shape. The \f$ \mathcal{L}^{2,1} \f$ is defined as:
\f[ \mathcal{L}^{2,1}(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert \mathbf{n}(x) - \mathbf{n}_i\Vert^2 dx. \f]

The \f$ \mathcal{L}^{2,1} \f$ is numerically superior to \f$ \mathcal{L}^2 \f$ in several ways:
- The anisotropy of the surface is better captured.
- Finding the best normal proxy is as simple as averaging the normals.

Figure \cgalFigureRef{relaxation} depicts the Lloyd iteration on the plane-sphere model with the \f$ \mathcal{L}^{2,1} \f$ metric.

\cgalFigureBegin{relaxation, relaxation.png}
Lloyd iterations on the plane-sphere model with the \f$ \mathcal{L}^{2,1} \f$ metric: (left) random initialization of 6 proxies; (center) after one iteration; (right) after 8 iterations, the regions settle. The red lines depict the proxy normals.
\cgalFigureEnd

The package provides both two metrics as `CGAL::L2Metric` and `CGAL::L21Metric`, respectively. The algorithm is not restricted to these two metrics and can be extended to other proxies and error metrics (see Section \ref sma_example3).

\subsection sma_init Initialization

(TODO: discuss choice of naming as initialization may confuse with seeding)

<!-- As indicated in the previous section, the iteration needs a set of initial proxies \f$ \{ P_1^0, \cdots, P_k^0 \} \f$.  -->

The algorithm must be initialized by determining either the number of proxies required to approximate the geometry or the maximum tolerance approximation error. More specifically, we can decide:
- <b>Target number of proxies</b>. The algorithm adds proxies until the specified target number is met.
- <b>Absolute error value</b>. The algorithm adds proxies until the approximation error is below the specified value. (WIP)
- <b>Target relative error drop</b>. We start from the proxy fitted from the first facet of the surface with the fitting error \f$ \hat E \f$. The algorithm adds proxies until the approximation error drops below the specified percentage \f$ target\_drop * \hat E \f$.

Different initialization examples are provided in \cgalFigureRef{meshing}.

(TODO: precise whether drop refers to relative drop rate or absolute value)

\subsection sma_seeding Seeding

Seeding is used to decide how to insert a new proxy.
In the implementation, each proxy is always associated with a <em>seed</em> facet. 
While the proxy parameters are viewed as the center in a geometric error sense, the seed of each proxy is used as the topological start point in the partition process.
When we want to add one more proxy to drive the approximation error down, 
we have to specify a facet of the surface as the seed to initialize the proxy parameters.

The package provides 3 different seeding methods:
- <b>Random</b>. The proxy seeds are picked randomly on the surface mesh.
- <b>Incremental</b>. Each time a proxy is initialized from a facet in the worst region.
- <b>Hierarchical</b>. The requested number of proxies are dispatched within current partition, where each region is added with the number of proxies proportional to their fitting error.

\cgalFigureBegin{seeding_method, seeding_method.png}
Comparison of different seeding methods on a sphere-cube union model, all with \f$ \mathcal{L}^{2,1} \f$ metrics and 20 proxies.
From left to right are random, incremental and hierarchical seeding respectively.
Notice the entrapped local minima in the yellow rectangles.
\cgalFigureEnd

From \cgalFigureRef{seeding_method} we can see the effect of different seeding methods to initialize the algorithm with targeted 20 proxies. 
Generally speaking, random initialization is random in position, very fast but can be entrapped in local minima areas (left), 
incremental one focuses on the most distorted region, interleaved with fitting process thus can be pretty slow. 
Hierarchical initialization gives fitting patches with more evenly distributed fitting errors and the time consumption is somewhere in between the former two. 
Some statistics and comparisons are available in \ref sma_perf.

\subsection sma_operations Operations

To yield better approximations of the geometry, some operations are available:
- <b>Merging</b>. Merging two adjacent regions.
- <b>Splitting</b>. Splitting larger region into smaller ones to reduce the error. It is a reverse operation to merging.
- <b>Adding</b>. Adding a proxy to further reduce the approximation error. As for the seeding process, we can choose between either incremental or hierarchical addition.
- <b>Teleportation</b>. It is a combination of merging and adding proxies: merging the local minimum region to its adjacent area and adding a proxy seed to the worst region.

\cgalFigureBegin{operations, operations.png}
Operations on the sphere-cube union model. Left: partition of 20 randomly initialized proxies after 10 iterations. Right: result after one merging and one teleportation operations.
\cgalFigureEnd

As depicted in \cgalFigureRef{operations}, teleportation provides a means to relocate a local minimum region entrapped in the planar plart (left) to the most needed regions on the sphere (right). In \ref sma_example2, the class interface is used to control the approximation process with above operations.

\subsection sma_extraction Mesh Extraction

This package also implements the meshing algorithm described in \cgalCite{cgal:cad-vsa-04}. More specifically, it attaches an anchor point to each intersection vertex and approximate the boundary of the geometry partition. Each polygon boundary is then triangulated and assembled to produce the output mesh. As there is no guarantee that the output mesh is 2-manifold and oriented, we provide an alternate output in the form of a triangle soup (indexed triangle set). 


\cgalFigureBegin{meshing, meshing.png}
Meshing the bear model with decreasing target error drop. 
From left to right, the target error drop are 6\%, 4\% and 2\% to the initial error respectively, the output mesh densify. 
Notice the boundary subdivision in the black rectangle area.
\cgalFigureEnd

In \cgalFigureRef{meshing}, the bear model is approximated through \f$ \mathcal{L}^{2,1} \f$ metric and the number of proxies are determined by error drop. 
The anchor points (black) are attached to the corresponding vertex on the mesh (white). 
The red lines connecting the anchor points approximate the boundary of each region.

When approximate the boundary of the proxy region, the recursive chord-length subdividing technique described in \cgalCite{cgal:cad-vsa-04} is used to give better approximation as illustrated in \cgalFigureRef{meshing}. Basically, we add an extra anchor point when the furthest vertex of distance \f$ d \f$ on the boundary arc \f$ (\mathbf{a}, \mathbf{b}) \f$ is too far away. The subdivision criterion is defined as:
\f[ d\cdot sin(\mathbf{N}_i,\mathbf{N}_j)/\Vert(\mathbf{a}, \mathbf{b})\Vert, \f]
where \f$ \mathbf{N}_i,\mathbf{N}_j \f$ is the normal of the proxies separated by the boundary arc \f$ (\mathbf{a}, \mathbf{b}) \f$. 
If the angle between proxy \f$ P_i \f$ and \f$ P_j \f$ is rather small, even a coarse approximation of the boundary will do: it does not add geometric information on the shape. 
On the contrary, when there is a large angle in between the two proxies, a more accurate discretization is desirable. \cgalCite{cgal:cad-vsa-04}

\subsection sma_api API

This package can be used either with `Polyhedron_3`, `Surface_mesh`, or any class model of the concept `FaceGraph` described in \ref chapterBGL.

Free function with \ref namedparameters options.
- `CGAL::vsa_mesh_approximation()` : given a triangle mesh, approximate the geometry with default \f$ \mathcal{L}^{2,1} \f$ metric.

Class interface:
- `CGAL::VSA_approximation`: allowing more customization of the proxy, metric and approximation process.

The input of the algorithm is expected to be:
- Combinatorially 2-manifold
- Triangulated

\section sma_examples Examples

\subsection sma_example1 Free Function

The following example calls the free function `CGAL::vsa_mesh_approximation()` on the input triangle mesh with default `CGAL::L21Metric`.

\cgalExample{Surface_mesh_approximation/vsa_example.cpp}

Note that the function parameters are provided through \ref namedparameters. 
To set the non-default parameter values, we just need to call the functions with the name of the required parameters connected by a dot in an arbitrary order like:

\code
// input: input triangle surface mesh
// output: output polyhedron surface mesh
typedef CGAL::Simple_cartesian<double> Kernel;
typedef CGAL::PlaneProxy<Kernel> PlaneProxy;
typedef std::map<face_descriptor, std::size_t> FIndexMap;
typedef boost::associative_property_map<FIndexMap> FProxyPMap;
FIndexMap fidx_map;
BOOST_FOREACH(face_discreptor f, faces(input))
  fidx_map[f] = 0;
// facet proxy index property map
FProxyPMap fpxmap(fidx_map);
// plane proxies;
std::vector<PlaneProxy> proxies;
vsa_mesh_approximation(input, output,
        CGAL::VSA::parameters::init_by_error(err_drop) // init the algorithm by target error drop
       .init_method(method) // set proxy seeding method in the initialization
       .iterations(num_iterations) // set number of fitting iterations after initialization
       .chord_subdivide(sub_thre) // set boundary subdivision threshold
       .facet_proxy_map(fpxmap) // get facet partition map
       .proxies(std::back_inserter(proxies))); // get proxies
// render the partition
...
// render proxies
...
\endcode

With the facet proxy index map and the output proxies, we render the partition and the proxy parameters as illustrated in \cgalFigureRef{relaxation}, etc. Obviously, the package can also be used as a partition algorithm:

\code
// fpxmap: the output facet partition map
vsa_mesh_approximation(input, output,
        CGAL::VSA::parameters::init_by_number(num_proxies)
       .init_method(method)
       .iterations(num_iterations)
       .facet_proxy_map(fpxmap));
\endcode

\subsection sma_example2 Class Interface

The following example uses the build-in `CGAL::L2Metric` to approximate the shape. The class interface `CGAL::VSA_approximation` offers a means to achieve flexible and interactive control of the algorithm.

\cgalExample{Surface_mesh_approximation/vsa_class_interface_example.cpp}

\subsection sma_example3 Self-defined Proxy and Metric

\cgalFigureBegin{vsa_metric_comparison, vsa_metric_comparison_200_30.png}
Comparison of different metrics on the bear model, all with 200 proxies and hierarchical seeding. From left to right: \f$ \mathcal{L}^{2,1} \f$ metric, \f$ \mathcal{L}^2 \f$ metric and compact metric.
\cgalFigureEnd

The following example defines a point-wise proxy to achieves an isotropic patch approximation of the shape. The output mesh is depicted in Figure \cgalFigureRef{vsa_metric_comparison}.

\cgalExample{Surface_mesh_approximation/vsa_metric_example.cpp}

\section sma_perf Performances

We provide some performance comparisons in this section with the free function API `CGAL::vsa_mesh_approximation`. 
The machine used is a PC running Windows10 X64 with an Intel Xeon E5-1620 clocked at 3.70 GHz with 32GB of RAM. 
The program has been optimized with the O2 option with Visual Studio 2015. By default the kernel used is `Exact_predicates_inexact_constructions_kernel` (`EPICK`).

Runtime in seconds with target number of proxies of different seeding method:

<center>
    Model    | \#Triangles | \#Proxies | Random | Incremental | Hierarchical
----------:  | ---------:  | -------:  | ----:  | ---------:  | -----------:
plane-sphere |    6,826    |     20    |     0  |     0.87    | 0.17
bear         |   20,188    |    200    |     0  |   36.749    | 1.194
masque       |   62,467    |    200    | 0.002  |  133.901    | 4.308
</center>

Runtime in seconds with target error drop of different seeding method. 
The benchmark is running on the bear model with 20,188 facets. 
Each column shows the time and the resulting number of proxies:

<center>
 Target Error Drop |   Random   | Incremental | Hierarchical
----------------:  | --------:  | ---------:  | -----------:
        0.06       |   1.03/64  |   9.053/53  | 1.017/64
        0.04       |  1.207/128 |  15.422/88  | 1.2/128
        0.02       |  1.415/256 |  35.171/192 | 1.428/256
</center>

Runtime of 3 phases of the algorithm in seconds: seeding, relaxation and meshing. 
The seeding method is hierarchical with target number of proxies.

<center>
    Model    | \#Triangles | \#Proxies | \#Iterations | Seeding | Relaxation | Meshing | Total
----------:  | ---------:  | -------:  | ----------:  | -----:  | --------:  | -----:  | ----:
plane-sphere |    6,826    |     20    |       20     |   0.17  |    0.228   | 0.044   | 0.442
bear         |   20,188    |    200    |       20     |  1.194  |    0.784   | 0.128   | 2.006
masque       |   62,467    |    200    |       20     |  4.308  |    2.974   | 0.349   | 7.631
</center>

<!-- With different metrics, we compare the running time and complexity of the output mesh.

<center>
    Model    | \#Triangles | \f$ \mathcal{L}^{2,1} \f$ | \f$ \mathcal{L}^2 \f$ | %Compact Metric
----------:  | ---------:  | -----------------------:  | -------------------:  | -------------:
plane-sphere |    6,826    |           tbd             |           tbd         | tbd
bear         |   20,188    |           tbd             |           tbd         | tbd
masque       |   62,467    |           tbd             |           tbd         | tbd
</center> -->

\section sma_history Design and Implementation History

This package is the result of the work of Lingjie Zhu during the 2017 season of the Google Summer of Code, mentored by Pierre Alliez. The code is based on an initial research code written by Pierre Alliez at Inria in 2003, for a paper published at the ACM SIGGRAPH conference in 2004 \cgalCite{cgal:cad-vsa-04}.

*/

}
