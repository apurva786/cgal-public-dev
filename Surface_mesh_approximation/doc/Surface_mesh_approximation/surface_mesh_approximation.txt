namespace CGAL {
/*!
\mainpage User Manual
\anchor Chapter_Triangulated_Surface_Mesh_Approximation

\cgalAutoToc
\authors Pierre Alliez, Lingjie Zhu

\cgalFigureBegin{Approximation_masque_main, masque_vsa.png}
Running the variational shape approximation on the mask model (62k triangles) with \f$ \mathcal{L}^{2,1} \f$ metric. 
Left: partition with 100 planar proxies on the input surface. 
Right: extracted triangle mesh with less than 250 triangles.
\cgalFigureEnd

\section sma_introduction Introduction

For many applications ranging from geometry compression to reverse engineering, finding the concise and faithful approximation of an excessively verbose 3D data (in particular, scanned meshes) is beneficial for subsequent processing and may reduce the computational cost dramatically.

This package implements the <em>Variational Shape Approximation</em> \cgalCite{cgal:cad-vsa-04} (VSA) method to approximate an input surface mesh by a simpler indexed face set or polyhedral surface mesh. 

Given an input surface triangle mesh, VSA leverages a discrete clustering algorithm to approximate it by a set of local simple shapes referred to as proxies. Each cluster is represented as a connected set of triangles of the input mesh, and the output mesh is constructed by generating a triangle approximation of the clusters. The approximation error is one-side, defined between the clusters and their associated proxies.

By default the proxies are planar, but the algorithm design is generic for future extensions to non-planar proxies. Two error metrics (\f$ \mathcal{L}^2 \f$, \f$ \mathcal{L}^{2,1} \f$) are provided, and the algorithm is generic to other user-defined metrics.

This package offers both the approximation and mesh construction functionalities. They can be accessed through the free function `CGAL::VSA::mesh_approximation()`, which runs a fully automated version of the algorithm:

\cgalExample{Surface_mesh_approximation/vsa_simple_approximation_example.cpp}

A class interface is also provided for advanced users, with interactive capabilities during clustering and customization in terms of error and proxies. Apart from approximation, the package can be used for shape segmentation via another free function to access the clustering partition.


\section sma_overview Overview

\subsection sma_clustering Clustering


Figure \cgalFigureRef{relaxation} depicts the Lloyd clustering iteration on the plane-sphere model with the \f$ \mathcal{L}^{2,1} \f$ metric.

\cgalFigureBegin{relaxation, relaxation.png}
Lloyd iterations on the plane-sphere model with the \f$ \mathcal{L}^{2,1} \f$ metric: (left) random initialization of 6 proxies; (center) after one iteration; (right) after 8 iterations, the regions settle. The red lines depict the proxy normals.
\cgalFigureEnd

The package provides both two metrics as `CGAL::VSA::L2_metric` and `CGAL::VSA::L21_metric`, respectively. The algorithm is not restricted to these two metrics and can be extended to other proxies and error metrics (see Section \ref sma_example4).

\subsection sma_init Initialization

<!-- As discussed above, the iteration needs a set of initial proxies \f$ \{ P_1^0, \cdots, P_k^0 \} \f$.  -->

The algorithm must be initialized by determining either the maximum number of proxies required to approximate the geometry or the minimum error drop rate between two iterations. More specifically, we can decide:
- <b>Maximum number of proxies</b>. The algorithm adds proxies until the specified target number is met.
- <b>Minimum error drop</b>. We start from the proxy fitted from the first facet of the surface with the fitting error \f$ \hat E \f$. The algorithm adds proxies until the approximation error drops below the specified percentage \f$ target\_drop * \hat E \f$, between two iterations.

Different initialization examples are provided in \cgalFigureRef{meshing}.

\subsection sma_seeding Seeding

Seeding is used to decide how to insert a new proxy. 
Each proxy is always associated with a <em>seed</em> triangle facet in the input surface mesh. 
While the proxy parameters are viewed as the center in a geometric error sense, the seed of each proxy is used as the topological start point in the partition process. When we want to add more proxies to drive the approximation error down, we must specify facets of the input surface mesh as seeds to initialize the proxy parameters.

The package provides 3 different seeding methods:
- <b>Random</b>. The proxy seeds are picked randomly on the surface mesh.
- <b>Incremental</b>. Each new proxy is initialized from a facet of the worse region matching the largest approximation error. The facet itself is chosen as the one realizing the largest error in its region.
- <b>Hierarchical</b>. The requested number of proxies are dispatched within the current partition, where each region is refined with a number of proxies chosen in accordance to their fitting error. 

(TODO: precise formula used and justify)

\cgalFigureBegin{seeding_method, seeding_method.png}
Comparison of different seeding methods on a sphere-cube union model, all with \f$ \mathcal{L}^{2,1} \f$ metrics and 20 proxies.
From left to right: random, incremental and hierarchical seeding.
Notice the entrapped local minima in the yellow rectangles.
\cgalFigureEnd

Figure \cgalFigureRef{seeding_method} depicts the effect of different seeding methods to initialize the algorithm with 20 proxies. Random initialization is random in choice of facets, very fast but can be entrapped in local minima areas espeically on shapes with regions surrounded by sharp creases (left). Incremental initialization adds proxies one by one, focusing on the most distorted region. It can thus be slow due to the interleaving with the clustering process. Hierarchical initialization yields fitting patches with more evenly distributed fitting errors, hence time consumption is somewhere in between the former two. Some statistics and comparisons are available in \ref sma_perf.

\subsection sma_operations Operations

For interactive use, the approach can yield better approximations of the geometry and tunnel out of local minima via additional operations:
- <b>Merging</b>. Merging two adjacent regions.
- <b>Splitting</b>. Splitting larger region into smaller ones to reduce the error. It is a reverse operation to merging.
- <b>Adding</b>. Adding a proxy to further reduce the approximation error. As for the seeding process, we can choose between either incremental or hierarchical addition.
- <b>Teleportation</b>. It is a combination of merging and adding proxies: merging the local minimum region to its adjacent area and adding a proxy seed to the worst region. More specifically, the pair of regions whose merging realizes the smallest error after merging and local re-fitting, is selected for merging.

\cgalFigureBegin{operations, operations.png}
Operations on the sphere-cube union model. Left: partition of 20 randomly initialized proxies after 10 iterations. Right: result after one merging and one teleportation operation.
\cgalFigureEnd

As depicted in \cgalFigureRef{operations}, teleportation provides a means to relocate a local minimum region entrapped in the planar plart (left) to the most needed regions on the sphere (right). In \ref sma_example3, the class interface is used to control the approximation process with above operations.

\subsection sma_extraction Mesh Extraction

This package implements the meshing algorithm described in \cgalCite{cgal:cad-vsa-04}. More specifically, it attaches an anchor point to each intersection vertex and approximate the boundary of the geometry partition. Each polygon boundary is then triangulated and assembled to produce the output mesh. As there is no guarantee that the output mesh is 2-manifold and oriented, the main input is an indexed triangle set, and additional output is possible in the form of a polyhedral surface mesh. 

\cgalFigureBegin{meshing, meshing.png}
Meshing the bear model with decreasing target error drop. 
From left to right, the target error drop are 6\%, 4\% and 2\% to the initial error respectively, the output mesh densifies. 
Notice the boundary subdivision in the black rectangle area.
\cgalFigureEnd

In \cgalFigureRef{meshing}, the bear model is approximated through \f$ \mathcal{L}^{2,1} \f$ metric and the final number of proxies is determined by monitoring the error drop. 
The anchor points (black) are attached to the corresponding vertex on the mesh (white). 
The red lines connecting the anchor points approximate the boundary of each region.

When approximate the boundary of the proxy region, the recursive chord-length subdividing technique described in \cgalCite{cgal:cad-vsa-04} is used to give better approximation as illustrated in \cgalFigureRef{meshing}. More specifically, we add an extra anchor point when the furthest vertex of distance \f$ d \f$ on the boundary arc \f$ (\mathbf{a}, \mathbf{b}) \f$ is too far away. The subdivision criterion is defined as: \f[ d\cdot sin(\mathbf{N}_i,\mathbf{N}_j)/\Vert(\mathbf{a}, \mathbf{b})\Vert, \f]
where \f$ \mathbf{N}_i,\mathbf{N}_j \f$ is the normal of the proxies separated by the boundary arc \f$ (\mathbf{a}, \mathbf{b}) \f$. If the angle between proxy \f$ P_i \f$ and \f$ P_j \f$ is rather small, even a coarse approximation will do as it does not add geometric information on the shape. 
On the contrary, when there is a large angle in between the two proxies, a more accurate discretization is desirable. \cgalCite{cgal:cad-vsa-04}

\subsection sma_api API

This package can be used either with `Polyhedron_3`, `Surface_mesh`, or any class model of the concept `FaceGraph` described in \ref chapterBGL.

Free function with \ref namedparameters options.
- `CGAL::VSA::mesh_approximation()` : given a triangle mesh, approximate the geometry with default \f$ \mathcal{L}^{2,1} \f$ metric.
- `CGAL::VSA::mesh_segmentation()` : given a triangle mesh, segment the geometry with default \f$ \mathcal{L}^{2,1} \f$ metric, no meshing process.

Class interface:
- `CGAL::VSA::Mesh_approximation`: allowing more customization of the proxy, metric and approximation process.

The input of the algorithm is expected to be:
- Combinatorially 2-manifold and oriented
- Triangulated

\section sma_examples Examples

\subsection sma_example1 Free Function Approximation

The following example calls the free function `CGAL::VSA::mesh_approximation()` on the input triangle mesh with default `CGAL::VSA::L21_metric`.

\cgalExample{Surface_mesh_approximation/vsa_approximation_example.cpp}

Note that the function parameters are provided through \ref namedparameters. To set the non-default parameter values, we need to call the functions with the name of the required parameters connected by a dot in an arbitrary order as follows:

TODO: add output indexed face set

\code
// input: input triangle surface mesh
// output: indexed face set
typedef CGAL::Simple_cartesian<double> Kernel;
typedef CGAL::VSA::Plane_proxy<Kernel::VSA> Plane_proxy;
typedef std::map<face_descriptor, std::size_t> Facet_index_map;
typedef boost::associative_property_map<Facet_index_map> Facet_proxy_pmap;
Facet_index_map fidx_map;
BOOST_FOREACH(face_discreptor f, faces(input))
  fidx_map[f] = 0;
// facet proxy index property map
Facet_proxy_pmap fpxmap(fidx_map);
// plane proxies;
std::vector<Plane_proxy> proxies;
CGAL::VSA::mesh_approximation(input, 
        CGAL::VSA::parameters::min_error_drop(err_drop) // init the algorithm by target error drop
       .init_method(method) // set proxy seeding method in the initialization
       .iterations(num_iterations) // set number of fitting iterations after initialization
       .mesh_chord_error(sub_thre) // set boundary approximation error threshold when meshing
       .facet_proxy_map(fpxmap) // get facet partition map
       .proxies(std::back_inserter(proxies))); // get proxies
// render the partition
...
// render proxies
...
\endcode

With the facet proxy index map and the output proxies, we render the partition and the proxy parameters as illustrated in \cgalFigureRef{relaxation}. 

\subsection sma_example2 Free Function Segmentation

The package can be used for segmenting via the free function `CGAL::VSA::mesh_segmentation()`, with the default `CGAL::VSA::L21_metric` approximation:

\cgalExample{Surface_mesh_approximation/vsa_segmentation_example.cpp}

\subsection sma_example3 Class Interface

The following example uses the build-in `CGAL::VSA::L2_metric` to approximate the shape. The class interface `CGAL::VSA::Mesh_approximation` offers a means to achieve flexible and interactive control of the algorithm.

\cgalExample{Surface_mesh_approximation/vsa_class_interface_example.cpp}

\subsection sma_example4 Self-defined Proxy and Metric

\cgalFigureBegin{vsa_metric_comparison, vsa_metric_comparison_200_30.png}
Comparison of different metrics on the bear model, all with 200 proxies and hierarchical seeding. From left to right: \f$ \mathcal{L}^{2,1} \f$ metric, \f$ \mathcal{L}^2 \f$ metric and compact metric.
\cgalFigureEnd

The following example defines a point-wise proxy to achieves an isotropic patch approximation of the shape. The output mesh is depicted in Figure \cgalFigureRef{vsa_metric_comparison}.

\cgalExample{Surface_mesh_approximation/vsa_isotropic_metric_example.cpp}

\section sma_perf Performances

We provide some performance comparisons in this section with the free function API `CGAL::VSA::mesh_approximation`. 
The machine used is a PC running Windows10 X64 with an Intel Xeon E5-1620 clocked at 3.70 GHz with 32GB of RAM. 
The program has been optimized with the O2 option with Visual Studio 2015. By default the kernel used is `Exact_predicates_inexact_constructions_kernel` (`EPICK`).

Runtime in seconds with target number of proxies of different seeding method:

<center>
    Model    | \#Triangles | \#Proxies | Random | Incremental | Hierarchical
----------:  | ---------:  | -------:  | ----:  | ---------:  | -----------:
plane-sphere |    6,826    |     20    |     0  |     0.87    | 0.17
bear         |   20,188    |    200    |     0  |   36.749    | 1.194
masque       |   62,467    |    200    | 0.002  |  133.901    | 4.308
</center>

Runtime in seconds with target error drop of different seeding method. 
The benchmark is running on the bear model with 20,188 facets. 
Each column shows the time and the resulting number of proxies:

<center>
 Target Error Drop |   Random   | Incremental | Hierarchical
----------------:  | --------:  | ---------:  | -----------:
        0.06       |   1.03/64  |   9.053/53  | 1.017/64
        0.04       |  1.207/128 |  15.422/88  | 1.2/128
        0.02       |  1.415/256 |  35.171/192 | 1.428/256
</center>

Runtime of 3 phases of the algorithm in seconds: seeding, relaxation and meshing. 
The seeding method is hierarchical with target number of proxies.

<center>
    Model    | \#Triangles | \#Proxies | \#Iterations | Seeding | Relaxation | Meshing | Total
----------:  | ---------:  | -------:  | ----------:  | -----:  | --------:  | -----:  | ----:
plane-sphere |    6,826    |     20    |       20     |   0.17  |    0.228   | 0.044   | 0.442
bear         |   20,188    |    200    |       20     |  1.194  |    0.784   | 0.128   | 2.006
masque       |   62,467    |    200    |       20     |  4.308  |    2.974   | 0.349   | 7.631
</center>

<!-- With different metrics, we compare the running time and complexity of the output mesh.

<center>
    Model    | \#Triangles | \f$ \mathcal{L}^{2,1} \f$ | \f$ \mathcal{L}^2 \f$ | %Compact Metric
----------:  | ---------:  | -----------------------:  | -------------------:  | -------------:
plane-sphere |    6,826    |           tbd             |           tbd         | tbd
bear         |   20,188    |           tbd             |           tbd         | tbd
masque       |   62,467    |           tbd             |           tbd         | tbd
</center> -->

\section sma_background

The VSA method has two key geometric concepts:

- <b>Proxies</b> \f$ P \f$. The parameterized best-fit geometric surrogates of a piece of surface geometry.

- <b>Error metrics</b> \f$ E \f$. To measure how well a proxy approximates the corresponding geometry.

Given an error metric \f$ E \f$, a desired number of \f$ k \f$ proxies, 
and an input surface \f$ S \f$, we denote by <em>optimal shape proxies</em> a set \f$ P \f$ of proxies \f$ P_i \f$ associated to the regions \f$ R_i\f$ of a partition \f$ \mathcal{R} \f$ of \f$ S \f$ that minimizes the total fitting error \cgalCite{cgal:cad-vsa-04}:

\f[ E(\mathcal{R}, P) = \sum_{i = 1..k} E(\mathcal{R}_i, P_i). \f]

By casting the approximation problem into an optimal discrete clustering one, the algorithm leverages the effective Lloyd algorithm \cgalCite{cgal:cad-vsa-04} to drive the total error down iteratively. 
More specifically, during each iteration two different steps are conducted, for the \f$ m \f$th iteration:
- <b>Partition process</b>. Firstly, all triangle facets are partitioned into \f$ k \f$ connected regions \f$ \{ R^{m}_1, \cdots, R^{m}_k \} \f$ by assigning each facet to its nearest proxy \f$ P^{m-1}_i \f$.
- <b>Fitting process</b>. Then, the algorithm fits a proxy and update the parameters \f$ P^{m}_i \f$ from the corresponding region \f$ R^{m}_i \f$.

For a sequence of iteration with the fitting error \f$ \{ E^1, \cdots, E^m \} \f$, the iteration is repeated until one of the stopping criteria is met:
- The maximum number of iteration is reached: \f$ m >= max\_iterations \f$.
- No significant error change between two iterations: \f$ (E^{m-1} - E^{m}) / E^{m-1} < converge\_threshold \f$.

\subsection sma_metrics Metrics and Proxies

Intuitively, each region \f$ \mathcal{R}_i \f$ of a partition \f$ \mathcal{R} \f$ can be summarily represented to first order as an "average" point \f$ X_i \f$ and an "average" normal \f$ N_i \f$. 
We denote such local representative pair \f$ P_i = (X_i, N_i) \f$, a <em>planar proxy</em> of the associated region. In the package, we provide such a planar proxy as `CGAL::VSA::Plane_proxy`.

Defining an appropriate error metric is the key ingredient for the algorithm. 
The \f$ \mathcal{L}^2 \f$ metric is defined as:
\f[ \mathcal{L}^2(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert x - \Pi_i(x)\Vert^2 dx. \f] where \f$ \Pi_i(\cdot) \f$ denotes the orthogonal projection of the argument onto the proxy plane passing through \f$ X_i \f$ and normal to \f$ N_i \f$. The \f$ \mathcal{L}^2 \f$ metric tries to match the input shape through approximation of the geometric position. 

In the paper \cgalCite{cgal:cad-vsa-04}, the author proposed the \f$ \mathcal{L}^{2,1} \f$ metrics, arguing that the normals are fundamental to the visual interpretation of the shape. The \f$ \mathcal{L}^{2,1} \f$ is defined as: \f[ \mathcal{L}^{2,1}(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert \mathbf{n}(x) - \mathbf{n}_i\Vert^2 dx. \f]

The \f$ \mathcal{L}^{2,1} \f$ is numerically superior to \f$ \mathcal{L}^2 \f$ in several ways:
- The anisotropy of the surface is better captured.
- Finding the best normal proxy is as simple as averaging the normals.


\section sma_history Design and Implementation History

This package is the result of the work of Lingjie Zhu during the 2017 season of the Google Summer of Code, mentored by Pierre Alliez. The code is based on an initial research code written by Pierre Alliez at Inria in 2003, for a paper published at the ACM SIGGRAPH conference in 2004 \cgalCite{cgal:cad-vsa-04}.

*/

}
