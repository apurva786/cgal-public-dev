namespace CGAL {
/*!
\mainpage User Manual
\anchor Chapter_Triangulated_Surface_Mesh_Approximation

\cgalAutoToc
\authors Pierre Alliez, Lingjie Zhu

\cgalFigureBegin{Approximation_masque_main, masque_vsa.png}
Running the variational shape approximation to the masque model. 
Left: the partition using 100 plane proxies on the input surface with 62K triangles. 
Right: the extracted triangle mesh with less than 250 triangles.
\cgalFigureEnd

\section sma_introduction Introduction

For many applications ranging from geometry compression to reverse engineering,
finding the concise and faithful approximation of an excessively verbose 3D data 
(in particular, scanned meshes) is beneficial for subsequent processing and may 
reduce the computational cost dramatically.

This package implements the <em>Variational Shape Approximation</em> \cgalCite{cgal:cad-vsa-04} (VSA) 
framework to approximate a triangle surface with shape primitives. Given a triangulated surface mesh 
(simply <em>mesh</em> in the following), the VSA uses the Lloyd's iteration \cgalCite{cgal:l-lsqp-82} 
to drive the distortion error down with the parameterized <em>geometric proxies</em>. The overview of the algorithm can be found in \ref sma_approximation.

This package offers both the approximation and mesh extraction functionalities. 
They can be accessed through a free function or more advanced interactive class-based interfaces with customized metric and proxy. 
Apart from approximation, it can be viewed as a package for simplification or shape discovery or a complement to current mesh segmentation package.

\section sma_overview Overview

\subsection sma_approximation Variational Shape Approximation

The VSA framework consists of two basic components:

- <em>Geometric proxies</em> \f$ P \f$ as a best-fit geometric surrogate to effectively circumvent topological issues; 

- <em>Shape error metrics</em> \f$ E \f$ to measure how well a proxy fits a piece of geometry \f$ \mathcal{R} \f$.

Given an error metric \f$ E \f$, a desired number \f$ k \f$ of proxies, 
and an input surface \f$ S \f$, we call optimal shape proxies a set \f$ P \f$ of proxies \f$ P_i \f$ 
associated to the regions \f$ R_i\f$ of a partition \f$ \mathcal{R} \f$ of \f$ S \f$ that minimizes the total distortion:

\f[ E(\mathcal{R}, P) = \sum_{i = 1..k} E(\mathcal{R}_i, P_i). \f]

By casting the approximation problem into an optimal discrete clustering one, 
the algorithm utilize the simple and effective Lloyd algorithm \cgalCite{cgal:cad-vsa-04} to drive the total error down iteratively. 
More specifically, every region can be characterized by a single, "average" proxy. 
After defining \f$ k \f$ proxy, all the triangle facets are partitioned into \f$ k \f$ regions by assigning each facet to its nearest proxy. 
Then, the algorithm updates the proxies \f$ P_i \f$ with each piece of corresponding region \f$ R_i \f$. This process is repeated until a stopping criterion is met.

\subsection sma_metrics Metrics on Proxies

Often each region \f$ \mathcal{R}_i \f$ of a partition \f$ \mathcal{R} \f$ can be summarily represented to first order as an "average" point \f$ X_i \f$ and an "average" normal \f$ N_i \f$. 
We denote such local representative pair \f$ P_i = (X_i, N_i) \f$, a <em>plane proxy</em> of the associated region. In the package, we provide such plane proxy as `CGAL::PlaneProxy`.

Defining an appropriate error metric is the key ingredient for the algorithm. 
The \f$ \mathcal{L}^2 \f$ metric is defined as:
\f[ \mathcal{L}^2(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert x - \Pi_i(x)\Vert^2 dx. \f] 
where \f$ \Pi_i(\cdot) \f$ denotes the orthogonal projection of the argument on the "proxy plane" goint through \f$ X_i \f$ and normal to \f$ N_i \f$.

The \f$ \mathcal{L}^2 \f$ metric tries to match geometry through approximation of the geometric position. 
In the paper \cgalCite{cgal:cad-vsa-04}, the author proposed a novel \f$ \mathcal{L}^{2,1} \f$ metrics with the belief that normal field is fundamental to the visual interpretation of the shape. The \f$ \mathcal{L}^{2,1} \f$ is defined as:
\f[ \mathcal{L}^{2,1}(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert \mathbf{n}(x) - \mathbf{n}_i\Vert^2 dx. \f]

The \f$ \mathcal{L}^{2,1} \f$ is numerically superior to \f$ \mathcal{L}^2 \f$ in several ways:
- The anisotropy of the surface is better captured.
- Finding the best normal proxy is as simple as averaging the normals.

In \cgalFigureRef{relaxation}, we showed the Lloyd optimization iteration on a plane-sphere model with the \f$ \mathcal{L}^{2,1} \f$ metric.

\cgalFigureBegin{relaxation, relaxation.png}
Optimization on the plane-shpere model with the \f$ \mathcal{L}^{2,1} \f$ metric: (left) random initialization of 6 partitions; (center) after one iteration of optimization; (right) after 8 iterations, the regions settle. The red line represent the proxy normal parameter.
\cgalFigureEnd

In the package, we provide both two metrics as `CGAL::L2Metric` and `CGAL::L21Metric` respectively. 
Of course, we are not limited to those two metrics. The algorithm framework is extensible and we could define our own metrics and plug it in as we can see in \ref sma_example3.

\subsection sma_seeding Seeding

It is no surprise that, the algorithm relies on the initial state of the proxies. There are 3 different seeding methods:
- <b>Random</b>. The proxies are initialized randomly from the geometry.
- <b>Incremental</b>. Each time a proxy is added to the furthest region.
- <b>Hierarchical</b>. Each time proxies are added to current partitions with the number in proportional to their fitting error.

\cgalFigureBegin{seeding_method, seeding_method.png}
Comparison of different seeding methods on a sphere-cube union model, all with \f$ \mathcal{L}^{2,1} \f$ metrics and 20 proxies.
From left to right are random, incremental and hierarchical seeding respectively. Notice the entrapped local minima areas in the red rectangles.
\cgalFigureEnd

From \cgalFigureRef{seeding_method} we can see the effect of different seeding strategies. Generally speaking, random initialization is even in position and very fast and can be entrapped in local minima areas, incremental one focuses on the most distorted region and can be pretty slow. Hierarchical initialization gives fitting patches with more evenly distributed fitting errors and the time consumption is somewhere in between the former two.

To determine how many proxies do we need to approximate the geometry. The package provides two approaches:
- <b>Target number of proxies</b>. The seeding process will stop once the target number is reached.
- <b>Target error drop</b>. The seeding process will stop once the fitting error is drop below the target to the initial fitting error.

The former one is straight-forward and examples of the latter one can be found in \cgalFigureRef{meshing}. Some statistics and comparisons are available in \ref sma_perf.

\subsection sma_operations Refinement Operations

To get better approximation of the geometry, some refinement operations are available to improve result.
- <b>Merging</b>. Merging two adjacent regions.
- <b>Splitting</b>. Splitting bigger region into smaller ones to reduce the error. It is a reverse operation to merging.
- <b>Adding</b>. Adding a proxy to reduce the fitting error and approximate the geometry better. Just like seeding process, we can choose either incremental or hierarchical method.
- <b>Teleportation</b>. It is a combination of merging and adding proxies: merging the local minimum region to its adjacent area and adding a proxy seed to other places.

\cgalFigureBegin{operations, operations.png}
Refinement operations.
\cgalFigureEnd

As we can see from \cgalFigureRef{operations}, teleportation could teleport entrapped local minima to the most needed regions and produce better result. In \ref sma_example2, the class interface is used to manipulate the approximation process with above operations.

\subsection sma_extraction Mesh Extraction

This package also implement the meshing algorithm described in \cgalCite{cgal:cad-vsa-04}. 
Basically, it attaches an anchor point to each intersection vertex and approximate the boundary of the geometry partition.
Then each polygon boundary is triangulated and assembled to produce the output mesh. 
Currently, there is no guarantee that the output mesh is 2-manifold and the package provide an alternate indexed triangles output.

\cgalFigureBegin{meshing, meshing.png}
Meshing with decreasing target error drop, the output mesh densify. 
From left to right, the target error drop are 6\%, 4\% and 2\% to the initial error respectively. 
Notice the boundary subdivision in the black rectangle area.
\cgalFigureEnd

In \cgalFigureRef{meshing}, the bear model is approximated through \f$ \mathcal{L}^{2,1} \f$ metric and the number of proxies are determined by error drop. 
The anchor points (black) are attached to the corresponding vertex on the mesh (white). 
The red lines connecting the anchor points approximate the boundary of each region.
When approximate the boundary of the proxy region, the subdivision technique described in \cgalCite{cgal:cad-vsa-04} is used to discretize the boundary as illustrated in \cgalFigureRef{meshing}.

\subsection sma_api API

This package can be used either with `Polyhedron_3`, `Surface_mesh`, or any class model of the concept `FaceGraph` described in \ref chapterBGL.

Free function with \ref namedparameters options.
- `CGAL::vsa_mesh_approximation()` : given a triangle mesh, approximate the geometry with default \f$ \mathcal{L}^{2,1} \f$ metric.

Class interface:
- `CGAL::VSA_approximation`: allowing more customization of the proxy, metric and approximation process.

The input of the algorithm is expected to be:
- Combinatorially 2-manifold
- Triangulated

\section sma_examples Examples

\subsection sma_example1 Free function

The following example calls the free function `CGAL::vsa_mesh_approximation()` on the input triangle mesh with default `CGAL::L21Metric`. 
The function parameters are provided through \ref namedparameters.

\cgalExample{Surface_mesh_approximation/vsa_example.cpp}

It can also be used as a partition algorithm:
\code
typedef boost::graph_traits<TriangleMesh>::face_descriptor face_descriptor;
// internal facet index map
std::map<face_descriptor, std::size_t> internal_fidx_map;
// boost property map with the facet proxy index as value
boost::associative_property_map<std::map<face_descriptor, std::size_t> > fpxmap(internal_fidx_map);
// num_iterations: number of relaxation iterations
// fpxmap: a facet proxy index property map
vsa_mesh_approximation(input, output,
        CGAL::VSA::parameters::init_method(method)
       .iterations(num_iterations)
       .facet_proxy_map(fpxmap));
\endcode

\subsection sma_example2 Class interface

\cgalFigureBegin{vsa_metric_comparison, vsa_metric_comparison_200_30.png}
Comparison of different metrics, all with 200 proxies and hierarchical seeding.
From left to right are \f$ \mathcal{L}^{2,1} \f$ metric, \f$ \mathcal{L}^2 \f$ metric and the compact metric in \ref sma_example3 respectively.
\cgalFigureEnd

The following example use the build-in `CGAL::L2Metric` to approximate the shape. 
With the class interface `CGAL::VSA_approximation`, we can achieve flexible and interactive manipulation of the algorithm.

\cgalExample{Surface_mesh_approximation/vsa_class_interface_example.cpp}

\subsection sma_example3 Self-defined proxy and metric

In the following example, it defines a simple point-wise proxy to achieves a compact patch approximation of the shape. The result is shown in \cgalFigureRef{vsa_metric_comparison}.

\cgalExample{Surface_mesh_approximation/vsa_metric_example.cpp}

\section sma_perf Performances

We provide some performance comparisons in this section with the free function API `CGAL::vsa_mesh_approximation`. 
The machine used is a PC running Windows10 X64 with an Intel Xeon E5-1620 clocked at 3.70 GHz with 32GB of RAM. 
The program has been optimized with the O2 option with Visual Studio 2015. By default the kernel used is `Exact_predicates_inexact_constructions_kernel` (`EPICK`).

Runtime in seconds with target number of proxies of different seeding method:

<center>
    Model    | \#Triangles | \#Proxies | Random | Incremental | Hierarchical
----------:  | ---------:  | -------:  | ----:  | ---------:  | -----------:
plane-sphere |    6,826    |     20    |     0  |     0.87    | 0.17
bear         |   20,188    |    200    |     0  |   36.749    | 1.194
masque       |   62,467    |    200    | 0.002  |  133.901    | 4.308
</center>

Runtime in seconds with target error drop of different seeding method. 
The benchmark is running on the bear model with 20,188 facets. 
Each column shows the time and the resulting number of proxies:

<center>
 Target Error Drop |   Random   | Incremental | Hierarchical
----------------:  | --------:  | ---------:  | -----------:
        0.06       |   1.03/64  |   9.053/53  | 1.017/64
        0.04       |  1.207/128 |  15.422/88  | 1.2/128
        0.02       |  1.415/256 |  35.171/192 | 1.428/256
</center>

Runtime of 3 phases of the algorithm in seconds: seeding, relaxation and meshing. 
The seeding method is hierarchical with target number of proxies.

<center>
    Model    | \#Triangles | \#Proxies | \#Iterations | Seeding | Relaxation | Meshing | Total
----------:  | ---------:  | -------:  | ----------:  | -----:  | --------:  | -----:  | ----:
plane-sphere |    6,826    |     20    |       20     |   0.17  |    0.228   | 0.044   | 0.442
bear         |   20,188    |    200    |       20     |  1.194  |    0.784   | 0.128   | 2.006
masque       |   62,467    |    200    |       20     |  4.308  |    2.974   | 0.349   | 7.631
</center>

<!-- With different metrics, we compare the running time and complexity of the output mesh.

<center>
    Model    | \#Triangles | \f$ \mathcal{L}^{2,1} \f$ | \f$ \mathcal{L}^2 \f$ | %Compact Metric
----------:  | ---------:  | -----------------------:  | -------------------:  | -------------:
plane-sphere |    6,826    |           tbd             |           tbd         | tbd
bear         |   20,188    |           tbd             |           tbd         | tbd
masque       |   62,467    |           tbd             |           tbd         | tbd
</center> -->

\section sma_history Design and Implementation History

This package is the result of the work of Lingjie Zhu during the 2017 season
of the Google Summer of Code. He has been mentored by Pierre Alliez.
The code is based on an initial research code written by Pierre Alliez in INRIA 2003,
for a paper published at \cgalCite{cgal:cad-vsa-04}.

*/

}
